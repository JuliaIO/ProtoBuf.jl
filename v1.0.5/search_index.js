var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]\nDepth = 3","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = ProtoBuf","category":"page"},{"location":"reference/#API-Reference","page":"Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Code-Generation","page":"Reference","title":"Code Generation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"protojl","category":"page"},{"location":"reference/#ProtoBuf.CodeGenerators.protojl","page":"Reference","title":"ProtoBuf.CodeGenerators.protojl","text":"protojl(\n    relative_paths::Union{String,Vector{String}},\n    search_directories::Union{String,Vector{String},Nothing}=nothing,\n    output_directory::Union{String,Nothing}=nothing;\n    include_vendored_wellknown_types::Bool=true,\n    always_use_modules::Bool=true,\n    force_required::Union{Nothing,Dict{String,Set{String}}}=nothing,\n    add_kwarg_constructors::Bool=false,\n    parametrize_oneofs::Bool=false,\n) -> Nothing\n\nGenerate Julia code for .proto files at relative_paths within search_directories and save it to output_directory.\n\nWhen compiling a {file_name}.proto files that do not have a package specifier, a {file_name}_pb.jl is generated in output_directory. When a {file_name}.proto contains e.g. package foo_bar.baz_grok, the following directory structure is created:\n\nroot  # `output_directory` arg from from `protojl`\n└── foo_bar\n    ├── foo_bar.jl  # defines module `foo_bar`, imports `baz_grok`\n    └── baz_grok\n        ├── {file_name}_pb.jl\n        └── baz_grok.jl  # defines module `baz_grok`, includes `{file_name}_pb.jl`\n\nYou should include the top-level module of a generated package, i.e. foo_bar.jl in this example. All imported .proto files are compiled as well; an error is thrown if they cannot be resolved or found within search_directories.\n\nArguments\n\nrelative_paths::Union{String,Vector{String}}: A path or paths to .proto files to be compiled.\nsearch_directories::Union{String,Vector{String},Nothing}=nothing: A directory or directories to search for relative_paths in. By default, the current directory is used.\noutput_directory::Union{String,Nothing}=nothing: Path to store the generated Julia source code. When omitted, the translated code is saved to temp directory, the path is shown as a @info log.\n\nKeywords\n\ninclude_vendored_wellknown_types::Bool=true: Append ProtoBuf.VENDORED_WELLKNOWN_TYPES_PARENT_PATH to search_directories, making the \"well-known\" message definitions available.\nalways_use_modules::Bool=true: Generate julia code in a module even if the .proto file doesn't contain a package specifier. The module name of {file_name}.proto file is {file_name}_pb.\nforce_required::Union{Nothing,Dict{String,Set{String}}}=nothing: Assume message and oneof fields to be aleways send over the wire – then we woudln't need to Union their respective types with Nothing. E.g:\n\n# force_required === nothing\nstruct MyMessage\n    message_field::Union{Nothing,MyOtherMessage}}\nend\n\n# force_required === Dict(\"{file_name}.proto\" => Set([\"MyMessage.message_field\"]))\nstruct MyMessage\n    message_field::MyOtherMessage}\nend\n\nadd_kwarg_constructors::Bool=false: For each message, generate an outer constructor with optional keyword arguments (if a field is a required message, there are no default values and the keyword argument is not optional).\nparametrize_oneofs::Bool=false: Add the OneOf type as a type parameter to the generated parent struct. I.e. this changes:\n\n# parametrize_oneofs == false\nstruct MyMessage\n    oneof_field::Union{Nothing, OneOf{<:Union{Int, String}}}\nend\n\nto\n\n# parametrize_oneofs == true\nstruct MyMessage{T1<:Union{Nothing, OneOf{<:Union{Int, String}}}}\n    oneof_field::T1\nend\n\nNotes\n\nWe use relative_paths and search_directories instead of absolute paths to resolve proto import statements which are using relative paths.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Encoding-and-Decoding","page":"Reference","title":"Encoding and Decoding","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"encode(::AbstractProtoEncoder, ::T) where {T}\ndecode(::AbstractProtoDecoder, ::Type{T}) where {T}","category":"page"},{"location":"reference/#ProtoBuf.Codecs.encode-Union{Tuple{T}, Tuple{ProtoBuf.Codecs.AbstractProtoEncoder, T}} where T","page":"Reference","title":"ProtoBuf.Codecs.encode","text":"encode(d::AbstractProtoDecoder, x::T) where {T}\n\nEncode struct x of type T as protobuf message to IO wrapped by AbstractProtoEncoder.\n\nFor general structs, these methods should be generated using the protojl function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ProtoBuf.Codecs.decode-Union{Tuple{T}, Tuple{ProtoBuf.Codecs.AbstractProtoDecoder, Type{T}}} where T","page":"Reference","title":"ProtoBuf.Codecs.decode","text":"decode(d::AbstractProtoDecoder, ::Type{T}) where {T}\n\nDecode a protobuf message from IO wrapped by AbstractProtoDecoder into s struct of type T.\n\nFor general structs, these methods should be generated using the protojl function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Metadata","page":"Reference","title":"Metadata","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"reserved_fields\nextendable_field_numbers\noneof_field_types\nfield_numbers\ndefault_values","category":"page"},{"location":"reference/#ProtoBuf.reserved_fields","page":"Reference","title":"ProtoBuf.reserved_fields","text":"reserved_fields(::Type{T}) where T\n\nReturn a named tuple of reserved field names and numbers from the original proto message definition. The numbers might be individual integers or integer ranges.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ProtoBuf.extendable_field_numbers","page":"Reference","title":"ProtoBuf.extendable_field_numbers","text":"extendable_field_numbers(::Type{T}) where T\n\nReturn extensions field numbers from the original proto message definition. The numbers might be individual integers or integer ranges.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ProtoBuf.oneof_field_types","page":"Reference","title":"ProtoBuf.oneof_field_types","text":"oneof_field_types(::Type{T}) where T\n\nReturn a named tuple of oneof field names to the full NamedTuple type describing the type individual oneof options. Returns an empty named tuple, (;), if the original proto message doesn't contain any oneof fields\n\n\n\n\n\n","category":"function"},{"location":"reference/#ProtoBuf.field_numbers","page":"Reference","title":"ProtoBuf.field_numbers","text":"field_numbers(::Type{T}) where T\n\nReturn a named tuple of fields names to their respective field numbers from the original proto message type. Fields of OneOf types are expanded as they don't map to any single field number.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ProtoBuf.default_values","page":"Reference","title":"ProtoBuf.default_values","text":"default_values(::Type{T}) where T\n\nReturn a named tuple of fields names to their respective default values from the original proto message type. Fields of OneOf types are expanded as they don't map to any single default value.\n\nrequired message-fields do not have a default value and are represented as Ref{MyFieldMessageType}().\n\n\n\n\n\n","category":"function"},{"location":"#ProtoBuf.jl-Documentation","page":"Home","title":"ProtoBuf.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ProtoBuf.jl provides a compiler and codec for Google's Protocol Buffers serialization format.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use the protojl function to translate your .proto files to Julia, then you can encode and decode your messages with","category":"page"},{"location":"","page":"Home","title":"Home","text":"encode(e::ProtoEncoder, x::YourMessage)\ndecode(d::ProtoDecoder, ::Type{YourMessage})","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where the ProtoEncoder and ProtoDecoder are simple types wrapping your IO.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is not currently registered, to install it, use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"ProtoBuf\")","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Given a test.proto file in your current working directory:","category":"page"},{"location":"","page":"Home","title":"Home","text":"syntax = \"proto3\";\n\nenum MyEnum {\n    DEFAULT = 0;\n    OTHER = 1;\n}\n\nmessage MyMessage {\n    sint32 a = 1;\n    repeated string b = 2;\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can generate Julia bindings with the protojl function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ProtoBuf\n\njulia> protojl(\"test.proto\", \".\", \"output_dir\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will create a Julia file at output_dir/test_pb.jl which you can simply include and start using it to encode and decode messages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> include(\"output_dir/test_pb.jl\")\nMain.test_pb\n\njulia> io = IOBuffer();\n\njulia> e = ProtoEncoder(io);\n\njulia> encode(e, test_pb.MyMessage(-1, [\"a\", \"b\"]))\n8\n\njulia> seekstart(io);\n\njulia> d = ProtoDecoder(io);\n\njulia> decode(d, test_pb.MyMessage)\nMain.test_pb.MyMessage(-1, [\"a\", \"b\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are curious, this is what the generated file looks like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Autogenerated using ProtoBuf.jl v0.1.0 on 2022-07-25T11:32:05.368\n# original file: /Users/tdrvostep/_proj/ProtoBuf.jl/test.proto (proto3 syntax)\n\nmodule test_pb\n\nimport ProtoBuf as PB\nusing ProtoBuf: OneOf\nusing EnumX: @enumx\n\nexport MyEnum, MyMessage\n\n@enumx MyEnum DEFAULT=0 OTHER=1\n\nstruct MyMessage\n    a::Int32\n    b::Vector{String}\nend\nPB.default_values(::Type{MyMessage}) = (;a = zero(Int32), b = Vector{String}())\nPB.field_numbers(::Type{MyMessage}) = (;a = 1, b = 2)\n\nfunction PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MyMessage})\n    a = zero(Int32)\n    b = PB.BufferedVector{String}()\n    while !PB.message_done(d)\n        field_number, wire_type = PB.decode_tag(d)\n        if field_number == 1\n            a = PB.decode(d, Int32, Val{:zigzag})\n        elseif field_number == 2\n            PB.decode!(d, b)\n        else\n            PB.skip(d, wire_type)\n        end\n    end\n    return MyMessage(a, b[])\nend\n\nfunction PB.encode(e::PB.AbstractProtoEncoder, x::MyMessage)\n    initpos = position(e.io)\n    x.a != zero(Int32) && PB.encode(e, 1, x.a, Val{:zigzag})\n    !isempty(x.b) && PB.encode(e, 2, x.b)\n    return position(e.io) - initpos\nend\nfunction PB._encoded_size(x::MyMessage)\n    encoded_size = 0\n    x.a != zero(Int32) && (encoded_size += PB._encoded_size(x.a, 1, Val{:zigzag}))\n    !isempty(x.b) && (encoded_size += PB._encoded_size(x.b, 2))\n    return encoded_size\nend\nend # module","category":"page"},{"location":"#Migrating-from-earlier-versions-of-ProtoBuf.jl","page":"Home","title":"Migrating from earlier versions of ProtoBuf.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Below is a list of notable differences that were introduced in 1.0.","category":"page"},{"location":"#Method-Names","page":"Home","title":"Method Names","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For translating proto files, use protojl function (previously protoc). To decode proto messages, use the decode method (previously readproto) and to encode Julia structs, use encode (previously writeproto). See Quickstart for an example.","category":"page"},{"location":"#Mutability","page":"Home","title":"Mutability","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Messages are now translated to immutable structs. This means that code that used the mutable structs to accumulate data will now have to prepare each field and construct the struct after all of them are ready.","category":"page"},{"location":"#Naming-Conventions","page":"Home","title":"Naming Conventions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The naming of nested messages and enums now generates names, that cannot collide with other definitions. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"message A {\n    message B {}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"now generates structs named A and var\"A.B\". In protobuf, it is legal to a define message called A_B but not A.B, which is a syntax to refer to these nested definitions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, field names that coincide with Julia reserved keywords were previously prefixed with an underscore (e.g. _function), now we prefix them with a # (e.g. var\"#function\").","category":"page"},{"location":"#Enumerations","page":"Home","title":"Enumerations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EnumX.jl is used to define enums instead of NamedTuples. This means that to get the type of the enum, one must use MyEnum.T as MyEnum is a Module. You can now dispatch on Base.Enum when working with @enumx-based enums.","category":"page"},{"location":"#oneof-Fields","page":"Home","title":"oneof Fields","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"oneof fields are now explicitly represented in the generated struct. Specifically, for a message","category":"page"},{"location":"","page":"Home","title":"Home","text":"message MyMessage {\n    oneof oneof_field {\n        int32 option1 = 1;\n        string option2 = 2;\n    }\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"a struct with a single field will be generated:","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct MyMessage\n   oneof_field::Union{Nothing,OneOf{<:Union{Int32,String}}}\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once instantiated, it will contain a value like OneOf{:option1, 42} or OneOf{:option2, \"The answer to life, the universe, and everything\"}. One can access the name and the value of the field via the :name and :value properties, respectively. Dereferencing the field will return the value of the field (e.g. my_message.oneof_field[] == 42)","category":"page"},{"location":"#Packages-and-Code-Structure","page":"Home","title":"Packages and Code Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For .proto files that are packages, a nested directory structure will be generated. For example, {file_name}.proto containing package foo_bar.baz_grok, the following directory structure is created:","category":"page"},{"location":"","page":"Home","title":"Home","text":"root  # `output_directory` arg from from `protojl`\n└── foo_bar\n    ├── foo_bar.jl  # defines module `foo_bar`, imports `baz_grok`\n    └── baz_grok\n        ├── {file_name}_pb.jl\n        └── baz_grok.jl  # defines module `baz_grok`, includes `{file_name}_pb.jl`","category":"page"},{"location":"","page":"Home","title":"Home","text":"You should include the top-level module of a generated package, i.e. foo_bar.jl in this example. When reading .proto files that use import statements, the imported files have to be located at the respective import paths relative to search_directories.","category":"page"},{"location":"","page":"Home","title":"Home","text":".proto files that don't have a package specifier will generate a single file containing a module. For example, {file_name}.proto will translate to a {file_name}_pb.jl file defining a {file_name}_pb module. You can generate a file without a module by providing always_use_modules=false options to protojl.","category":"page"},{"location":"#Constructors","page":"Home","title":"Constructors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"By default, there are no additional constructors generated for the Julia structs. You can use the add_kwarg_contructors=true option to protojl to create outer constructors that accept keyword arguments and provide default values where available.","category":"page"},{"location":"faq/#Frequently-Asked-Questions","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#How-do-I-work-with-.textproto-files?","page":"FAQ","title":"How do I work with .textproto files?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":".textproto files are not currently supported by this package. You can, however, use the protoc compiler (e.g. via the protoc_jll package) to translate between text and binary formats using the --encode and --decode commands.","category":"page"},{"location":"faq/#How-do-I-work-with-oneof-fields?","page":"FAQ","title":"How do I work with oneof fields?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"A oneof field represents a set of possible fields (members) of which only one can be set at a time. Individual members of a oneof field cannot be distinguished by their type alone, one needs to know the respective member field name as well. In this package, we use a OneOf{T} type to represent the chosen member, is only has two fields: a value::T and a name::Symbol. Dereferencing a OneOf instance will return the value.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Because Protocol Buffers stress that one needs to handle situations where message definitions evolve and when data transfer can fail, we need to have a default value for all fields, oneof fields included. Given multiple members, there is no clear default value to choose, so we represent the absence of a OneOf instance with nothing. This means that, by default, all oneof fields are presented as Union{Nothing,OneOf{...}} in Julia. These unions can sometimes be tricky to reason about for the Julia compiler so we recommend the following when working with OneOf types:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Try to manually split the Union, i.e. instead of","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"if !isnothing(my_message.one_of_field)\nelseif my_message.one_of_field === :option1\n    do_someting(my_message.one_of_field[])\nelseif my_message.one_of_field === :option2\n    do_someting_else(my_message.one_of_field[])\n# ...\nend","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"do this:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"one_of_field = my_message.one_of_field\nif !isnothing(one_of_field)\nelseif one_of_field === :option1\n    do_someting(one_of_field[])\nelseif one_of_field === :option2\n    do_someting_else(one_of_field[])\n# ...\nend","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"When you know that the oneof field is guaranteed to be received when decoding, you can tell the protojl not to use a Union by providing a force_requires keyword argument with Dict(\"my_proto_file.proto\" => Set(\"MyMessage.one_of_field\")).\nYou can parametrize your structs on the type of oneofs by providing a parametrize_oneofs=true keyword argument to protojl.","category":"page"},{"location":"faq/#How-complete-is-this-package?","page":"FAQ","title":"How complete is this package?","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"The package should have fairly complete support for both proto2 and proto3 syntaxes with the following exceptions:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Services and RPC are not yet supported\nExtensions are not yet supported\nText Format is not yet supported (but see How do I work with .textproto files?)","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Future development will focus on Services and RPC with an overall goal of getting a new, native Julia gRPC implementation.","category":"page"}]
}
